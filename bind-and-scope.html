<html>
<head>
    <title>Rust Programming Language</title>
    <link href="imgs/favicon.ico" type="image/png" rel="shortcut icon">
    
    <link href="css/style.css" rel="stylesheet">
    
    <script src="js/jquery-2.2.2.js"></script>
    <script src="js/script.js"></script>
</head>
<body>

<header>
    <a href="index.html"><img width="70" id="headerImg" src="imgs/favicon.ico"></a>
    <h1>Rust Programming Language</h1>
    <h2>Jesse Rupe ~ Will Ross ~ Jake Blow</h2>
    <hr>
</header>

<div id="sidebar">
    <a href="index.html" style="display: none">
        <h3>Index</h3>
    </a>
    <a href="history.html">
        <h3>History</h3>
    </a>
    <hr>
    <a href="features.html">
        <h3>Features</h3>
    </a>
    <a href="pattern-matching.html">
        <h5>Pattern<br>Matching</h5>
    </a>
    <a href="structs-enums.html">
        <h5>Structs<br>&amp; Enums</h5>
    </a>
    <a href="bind-and-scope.html">
        <h5 id="selected">Bindings<br>&amp; Scope</h5>
    </a>
    <a href="object-ownership.html">
        <h5>Object<br>Ownership</h5>
    </a>
    <a href="methods.html">
        <h5>Methods</h5>
    </a>
    <a href="concurrency.html">
        <h5>Concurrency</h5>
    </a>
    <a href="conclusion.html">
        <h5>Conclusion</h5>
    </a>
</div>
<div id="content">
    <h2>Bindings and Scope</h2>
    <div id="contentDetails">
        <div id="contentLeft">
            <h3 tabindex="0">Binding</h3>
			<p tabindex="1">
            In addition to conventional static typing, prior to version 0.4 Rust also supported typestates. The typestate system modeled assertions before and after program statements, through use of a special check statement. Discrepancies could be discovered at compile time, rather than once a program was running, as might be the case with assertions in C or C++ code. The typestate concept was not unique to Rust, as it was first introduced in the NIL programming language. Typestates were removed because in practice they found little use, though the same functionality can still be achieved with branding patterns.
			<p>
			<br tabindex="2">
        </div>

<div></div>        

        <div id="contentDivide"></div>
		<div id="contentRight">
            <h3 tabindex="3">Scope and GC</h3>
			<p tabindex="4">
			Is Rust garbage collected?
No. One of Rustâ€™s key innovations is guaranteeing memory safety (no segfaults) without requiring garbage collection.

By avoiding GC, Rust can offer numerous benefits: predictable cleanup of resources, lower overhead for memory management, and essentially no runtime system. All of these traits make Rust lean and easy to embed into arbitrary contexts, and make it much easier to integrate Rust code with languages that have a GC.

Rust avoids the need for GC through its system of ownership and borrowing, but that same system helps with a host of other problems, including resource management in general and concurrency.

For when single ownership does not suffice, Rust programs rely on the standard reference-counting smart pointer type, Rc, and its thread-safe counterpart, Arc, instead of GC.

We are however investigating optional garbage collection as a future extension. The goal is to enable smooth integration with garbage-collected runtimes, such as those offered by the Spidermonkey and V8 JavaScript engines. Finally, some people have investigated implementing pure Rust garbage collectors without compiler support.
			</p>
            <br>
        </div>
    </div>

<div> </div>

</div>
</body>
</html>
